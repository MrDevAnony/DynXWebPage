window.dohjs = function (e) { var t = {}; function n(r) { if (t[r]) return t[r].exports; var o = t[r] = { i: r, l: !1, exports: {} }; return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports } return n.m = e, n.c = t, n.d = function (e, t, r) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r }) }, n.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.t = function (e, t) { if (1 & t && (e = n(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var o in e) n.d(r, o, function (t) { return e[t] }.bind(null, o)); return r }, n.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return n.d(t, "a", t), t }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, n.p = "", n(n.s = 2) }([function (e, t, n) { "use strict"; const r = n(7), o = n(8), i = n(9), s = n(10), u = n(11), c = n(13).Buffer, a = t.txt = t.name = {}; a.encode = function (e, t, n) { t || (t = c.allocUnsafe(a.encodingLength(e))), n || (n = 0); const r = n, o = e.replace(/^\.|\.$/gm, ""); if (o.length) { const e = o.split("."); for (let r = 0; r < e.length; r++) { const o = t.write(e[r], n + 1); t[n] = o, n += o + 1 } } return t[n++] = 0, a.encode.bytes = n - r, t }, a.encode.bytes = 0, a.decode = function (e, t) { t || (t = 0); const n = [], r = t; let o = e[t++]; if (0 === o) return a.decode.bytes = 1, "."; if (o >= 192) { const n = a.decode(e, e.readUInt16BE(t - 1) - 49152); return a.decode.bytes = 2, n } for (; o;) { if (o >= 192) { n.push(a.decode(e, e.readUInt16BE(t - 1) - 49152)), t++; break } n.push(e.toString("utf-8", t, t + o)), t += o, o = e[t++] } return a.decode.bytes = t - r, n.join(".") }, a.decode.bytes = 0, a.encodingLength = function (e) { return "." === e ? 1 : c.byteLength(e) + 2 }; const f = { encode: function (e, t, n) { t || (t = c.allocUnsafe(f.encodingLength(e))), n || (n = 0); const r = t.write(e, n + 1); return t[n] = r, f.encode.bytes = r + 1, t } }; f.encode.bytes = 0, f.decode = function (e, t) { t || (t = 0); const n = e[t], r = e.toString("utf-8", t + 1, t + 1 + n); return f.decode.bytes = n + 1, r }, f.decode.bytes = 0, f.encodingLength = function (e) { return c.byteLength(e) + 1 }; const h = { encode: function (e, t, n) { t || (t = h.encodingLength(e)), n || (n = 0); const r = 32767 & (e.flags || 0), o = "response" === e.type ? 32768 : 0; return t.writeUInt16BE(e.id || 0, n), t.writeUInt16BE(r | o, n + 2), t.writeUInt16BE(e.questions.length, n + 4), t.writeUInt16BE(e.answers.length, n + 6), t.writeUInt16BE(e.authorities.length, n + 8), t.writeUInt16BE(e.additionals.length, n + 10), t } }; h.encode.bytes = 12, h.decode = function (e, t) { if (t || (t = 0), e.length < 12) throw new Error("Header must be 12 bytes"); const n = e.readUInt16BE(t + 2); return { id: e.readUInt16BE(t), type: 32768 & n ? "response" : "query", flags: 32767 & n, flag_qr: 1 == (n >> 15 & 1), opcode: i.toString(n >> 11 & 15), flag_aa: 1 == (n >> 10 & 1), flag_tc: 1 == (n >> 9 & 1), flag_rd: 1 == (n >> 8 & 1), flag_ra: 1 == (n >> 7 & 1), flag_z: 1 == (n >> 6 & 1), flag_ad: 1 == (n >> 5 & 1), flag_cd: 1 == (n >> 4 & 1), rcode: o.toString(15 & n), questions: new Array(e.readUInt16BE(t + 4)), answers: new Array(e.readUInt16BE(t + 6)), authorities: new Array(e.readUInt16BE(t + 8)), additionals: new Array(e.readUInt16BE(t + 10)) } }, h.decode.bytes = 12, h.encodingLength = function () { return 12 }; const d = t.unknown = {}; d.encode = function (e, t, n) { return t || (t = c.allocUnsafe(d.encodingLength(e))), n || (n = 0), t.writeUInt16BE(e.length, n), e.copy(t, n + 2), d.encode.bytes = e.length + 2, t }, d.encode.bytes = 0, d.decode = function (e, t) { t || (t = 0); const n = e.readUInt16BE(t), r = e.slice(t + 2, t + 2 + n); return d.decode.bytes = n + 2, r }, d.decode.bytes = 0, d.encodingLength = function (e) { return e.length + 2 }; const l = t.ns = {}; l.encode = function (e, t, n) { return t || (t = c.allocUnsafe(l.encodingLength(e))), n || (n = 0), a.encode(e, t, n + 2), t.writeUInt16BE(a.encode.bytes, n), l.encode.bytes = a.encode.bytes + 2, t }, l.encode.bytes = 0, l.decode = function (e, t) { t || (t = 0); const n = e.readUInt16BE(t), r = a.decode(e, t + 2); return l.decode.bytes = n + 2, r }, l.decode.bytes = 0, l.encodingLength = function (e) { return a.encodingLength(e) + 2 }; const g = t.soa = {}; g.encode = function (e, t, n) { t || (t = c.allocUnsafe(g.encodingLength(e))), n || (n = 0); const r = n; return n += 2, a.encode(e.mname, t, n), n += a.encode.bytes, a.encode(e.rname, t, n), n += a.encode.bytes, t.writeUInt32BE(e.serial || 0, n), n += 4, t.writeUInt32BE(e.refresh || 0, n), n += 4, t.writeUInt32BE(e.retry || 0, n), n += 4, t.writeUInt32BE(e.expire || 0, n), n += 4, t.writeUInt32BE(e.minimum || 0, n), n += 4, t.writeUInt16BE(n - r - 2, r), g.encode.bytes = n - r, t }, g.encode.bytes = 0, g.decode = function (e, t) { t || (t = 0); const n = t, r = {}; return t += 2, r.mname = a.decode(e, t), t += a.decode.bytes, r.rname = a.decode(e, t), t += a.decode.bytes, r.serial = e.readUInt32BE(t), t += 4, r.refresh = e.readUInt32BE(t), t += 4, r.retry = e.readUInt32BE(t), t += 4, r.expire = e.readUInt32BE(t), t += 4, r.minimum = e.readUInt32BE(t), t += 4, g.decode.bytes = t - n, r }, g.decode.bytes = 0, g.encodingLength = function (e) { return 22 + a.encodingLength(e.mname) + a.encodingLength(e.rname) }; const p = t.txt = {}; p.encode = function (e, t, n) { Array.isArray(e) || (e = [e]); for (let t = 0; t < e.length; t++)if ("string" == typeof e[t] && (e[t] = c.from(e[t])), !c.isBuffer(e[t])) throw new Error("Must be a Buffer"); t || (t = c.allocUnsafe(p.encodingLength(e))), n || (n = 0); const r = n; return n += 2, e.forEach((function (e) { t[n++] = e.length, e.copy(t, n, 0, e.length), n += e.length })), t.writeUInt16BE(n - r - 2, r), p.encode.bytes = n - r, t }, p.encode.bytes = 0, p.decode = function (e, t) { t || (t = 0); const n = t; let r = e.readUInt16BE(t); t += 2; let o = []; for (; r > 0;) { const n = e[t++]; if (--r, r < n) throw new Error("Buffer overflow"); o.push(e.slice(t, t + n)), t += n, r -= n } return p.decode.bytes = t - n, o }, p.decode.bytes = 0, p.encodingLength = function (e) { Array.isArray(e) || (e = [e]); let t = 2; return e.forEach((function (e) { t += "string" == typeof e ? c.byteLength(e) + 1 : e.length + 1 })), t }; const y = t.null = {}; y.encode = function (e, t, n) { t || (t = c.allocUnsafe(y.encodingLength(e))), n || (n = 0), "string" == typeof e && (e = c.from(e)), e || (e = c.allocUnsafe(0)); const r = n; n += 2; const o = e.length; return e.copy(t, n, 0, o), n += o, t.writeUInt16BE(n - r - 2, r), y.encode.bytes = n - r, t }, y.encode.bytes = 0, y.decode = function (e, t) { t || (t = 0); const n = t, r = e.readUInt16BE(t); t += 2; const o = e.slice(t, t + r); return t += r, y.decode.bytes = t - n, o }, y.decode.bytes = 0, y.encodingLength = function (e) { return e ? (c.isBuffer(e) ? e.length : c.byteLength(e)) + 2 : 2 }; const E = t.hinfo = {}; E.encode = function (e, t, n) { t || (t = c.allocUnsafe(E.encodingLength(e))), n || (n = 0); const r = n; return n += 2, f.encode(e.cpu, t, n), n += f.encode.bytes, f.encode(e.os, t, n), n += f.encode.bytes, t.writeUInt16BE(n - r - 2, r), E.encode.bytes = n - r, t }, E.encode.bytes = 0, E.decode = function (e, t) { t || (t = 0); const n = t, r = {}; return t += 2, r.cpu = f.decode(e, t), t += f.decode.bytes, r.os = f.decode(e, t), t += f.decode.bytes, E.decode.bytes = t - n, r }, E.decode.bytes = 0, E.encodingLength = function (e) { return f.encodingLength(e.cpu) + f.encodingLength(e.os) + 2 }; const b = t.ptr = {}, w = t.cname = b, A = t.dname = b; b.encode = function (e, t, n) { return t || (t = c.allocUnsafe(b.encodingLength(e))), n || (n = 0), a.encode(e, t, n + 2), t.writeUInt16BE(a.encode.bytes, n), b.encode.bytes = a.encode.bytes + 2, t }, b.encode.bytes = 0, b.decode = function (e, t) { t || (t = 0); const n = a.decode(e, t + 2); return b.decode.bytes = a.decode.bytes + 2, n }, b.decode.bytes = 0, b.encodingLength = function (e) { return a.encodingLength(e) + 2 }; const U = t.srv = {}; U.encode = function (e, t, n) { t || (t = c.allocUnsafe(U.encodingLength(e))), n || (n = 0), t.writeUInt16BE(e.priority || 0, n + 2), t.writeUInt16BE(e.weight || 0, n + 4), t.writeUInt16BE(e.port || 0, n + 6), a.encode(e.target, t, n + 8); const r = a.encode.bytes + 6; return t.writeUInt16BE(r, n), U.encode.bytes = r + 2, t }, U.encode.bytes = 0, U.decode = function (e, t) { t || (t = 0); const n = e.readUInt16BE(t), r = {}; return r.priority = e.readUInt16BE(t + 2), r.weight = e.readUInt16BE(t + 4), r.port = e.readUInt16BE(t + 6), r.target = a.decode(e, t + 8), U.decode.bytes = n + 2, r }, U.decode.bytes = 0, U.encodingLength = function (e) { return 8 + a.encodingLength(e.target) }; const m = t.caa = {}; m.ISSUER_CRITICAL = 128, m.encode = function (e, t, n) { const r = m.encodingLength(e); return t || (t = c.allocUnsafe(m.encodingLength(e))), n || (n = 0), e.issuerCritical && (e.flags = m.ISSUER_CRITICAL), t.writeUInt16BE(r - 2, n), n += 2, t.writeUInt8(e.flags || 0, n), n += 1, f.encode(e.tag, t, n), n += f.encode.bytes, t.write(e.value, n), n += c.byteLength(e.value), m.encode.bytes = r, t }, m.encode.bytes = 0, m.decode = function (e, t) { t || (t = 0); const n = e.readUInt16BE(t), r = t += 2, o = {}; return o.flags = e.readUInt8(t), t += 1, o.tag = f.decode(e, t), t += f.decode.bytes, o.value = e.toString("utf-8", t, r + n), o.issuerCritical = !!(o.flags & m.ISSUER_CRITICAL), m.decode.bytes = n + 2, o }, m.decode.bytes = 0, m.encodingLength = function (e) { return f.encodingLength(e.tag) + f.encodingLength(e.value) + 2 }; const v = t.mx = {}; v.encode = function (e, t, n) { t || (t = c.allocUnsafe(v.encodingLength(e))), n || (n = 0); const r = n; return n += 2, t.writeUInt16BE(e.preference || 0, n), n += 2, a.encode(e.exchange, t, n), n += a.encode.bytes, t.writeUInt16BE(n - r - 2, r), v.encode.bytes = n - r, t }, v.encode.bytes = 0, v.decode = function (e, t) { t || (t = 0); const n = t, r = {}; return t += 2, r.preference = e.readUInt16BE(t), t += 2, r.exchange = a.decode(e, t), t += a.decode.bytes, v.decode.bytes = t - n, r }, v.encodingLength = function (e) { return 4 + a.encodingLength(e.exchange) }; const I = t.a = {}; I.encode = function (e, t, n) { return t || (t = c.allocUnsafe(I.encodingLength(e))), n || (n = 0), t.writeUInt16BE(4, n), n += 2, u.toBuffer(e, t, n), I.encode.bytes = 6, t }, I.encode.bytes = 0, I.decode = function (e, t) { t || (t = 0), t += 2; const n = u.toString(e, t, 4); return I.decode.bytes = 6, n }, I.decode.bytes = 0, I.encodingLength = function () { return 6 }; const R = t.aaaa = {}; R.encode = function (e, t, n) { return t || (t = c.allocUnsafe(R.encodingLength(e))), n || (n = 0), t.writeUInt16BE(16, n), n += 2, u.toBuffer(e, t, n), R.encode.bytes = 18, t }, R.encode.bytes = 0, R.decode = function (e, t) { t || (t = 0), t += 2; const n = u.toString(e, t, 16); return R.decode.bytes = 18, n }, R.decode.bytes = 0, R.encodingLength = function () { return 18 }; const B = t.option = {}; B.encode = function (e, t, n) { t || (t = c.allocUnsafe(B.encodingLength(e))), n || (n = 0); const r = n; return t.writeUInt16BE(e.code, n), n += 2, t.writeUInt16BE(e.data.length, n), n += 2, e.data.copy(t, n), n += e.data.length, B.encode.bytes = n - r, t }, B.encode.bytes = 0, B.decode = function (e, t) { t || (t = 0); const n = {}; n.code = e.readUInt16BE(t); const r = e.readUInt16BE(t + 2); return n.data = e.slice(t + 4, t + 4 + r), B.decode.bytes = r + 4, n }, B.decode.bytes = 0, B.encodingLength = function (e) { return e.data.length + 4 }; const S = t.opt = {}; S.encode = function (e, t, n) { t || (t = c.allocUnsafe(S.encodingLength(e))), n || (n = 0); const r = n, o = P(e, B); return t.writeUInt16BE(o, n), n = T(e, B, t, n + 2), S.encode.bytes = n - r, t }, S.encode.bytes = 0, S.decode = function (e, t) { t || (t = 0); const n = t, r = []; let o = e.readUInt16BE(t); t += 2; let i = 0; for (; o > 0;)r[i++] = B.decode(e, t), t += B.decode.bytes, o -= B.decode.bytes; return S.decode.bytes = t - n, r }, S.decode.bytes = 0, S.encodingLength = function (e) { return 2 + P(e || [], B) }; const _ = t.record = function (e) { switch (e.toUpperCase()) { case "A": return I; case "PTR": return b; case "CNAME": return w; case "DNAME": return A; case "TXT": return p; case "NULL": return y; case "AAAA": return R; case "SRV": return U; case "HINFO": return E; case "CAA": return m; case "NS": return l; case "SOA": return g; case "MX": return v; case "OPT": return S }return d }, O = t.answer = {}; O.encode = function (e, t, n) { t || (t = c.allocUnsafe(O.encodingLength(e))), n || (n = 0); const o = n; if (a.encode(e.name, t, n), n += a.encode.bytes, t.writeUInt16BE(r.toType(e.type), n), "OPT" === e.type.toUpperCase()) { if ("." !== e.name) throw new Error("OPT name must be root."); t.writeUInt16BE(e.updPayloadSize || 4096, n + 2), t.writeUInt8(e.extendedRcode || 0, n + 4), t.writeUInt8(e.ednsVersion || 0, n + 5), t.writeUInt16BE(e.flags || 0, n + 6), n += 8, S.encode(e.options || [], t, n), n += S.encode.bytes } else { let r = s.toClass(void 0 === e.class ? "IN" : e.class); e.flush && (r |= 32768), t.writeUInt16BE(r, n + 2), t.writeUInt32BE(e.ttl || 0, n + 4), n += 8; const o = _(e.type); o.encode(e.data, t, n), n += o.encode.bytes } return O.encode.bytes = n - o, t }, O.encode.bytes = 0, O.decode = function (e, t) { t || (t = 0); const n = {}, o = t; if (n.name = a.decode(e, t), t += a.decode.bytes, n.type = r.toString(e.readUInt16BE(t)), "OPT" === n.type) n.udpPayloadSize = e.readUInt16BE(t + 2), n.extendedRcode = e.readUInt8(t + 4), n.ednsVersion = e.readUInt8(t + 5), n.flags = e.readUInt16BE(t + 6), n.flag_do = 1 == (n.flags >> 15 & 1), n.options = S.decode(e, t + 8), t += 8 + S.decode.bytes; else { const r = e.readUInt16BE(t + 2); n.ttl = e.readUInt32BE(t + 4), n.class = s.toString(-32769 & r), n.flush = !!(32768 & r); const o = _(n.type); n.data = o.decode(e, t + 8), t += 8 + o.decode.bytes } return O.decode.bytes = t - o, n }, O.decode.bytes = 0, O.encodingLength = function (e) { return a.encodingLength(e.name) + 8 + _(e.type).encodingLength(e.data || e.options) }; const L = t.question = {}; function P(e, t) { let n = 0; for (let r = 0; r < e.length; r++)n += t.encodingLength(e[r]); return n } function T(e, t, n, r) { for (let o = 0; o < e.length; o++)t.encode(e[o], n, r), r += t.encode.bytes; return r } function C(e, t, n, r) { for (let o = 0; o < e.length; o++)e[o] = t.decode(n, r), r += t.decode.bytes; return r } L.encode = function (e, t, n) { t || (t = c.allocUnsafe(L.encodingLength(e))), n || (n = 0); const o = n; return a.encode(e.name, t, n), n += a.encode.bytes, t.writeUInt16BE(r.toType(e.type), n), n += 2, t.writeUInt16BE(s.toClass(void 0 === e.class ? "IN" : e.class), n), n += 2, L.encode.bytes = n - o, e }, L.encode.bytes = 0, L.decode = function (e, t) { t || (t = 0); const n = t, o = {}; return o.name = a.decode(e, t), t += a.decode.bytes, o.type = r.toString(e.readUInt16BE(t)), t += 2, o.class = s.toString(e.readUInt16BE(t)), t += 2, !!(32768 & o.class) && (o.class &= -32769), L.decode.bytes = t - n, o }, L.decode.bytes = 0, L.encodingLength = function (e) { return a.encodingLength(e.name) + 4 }, t.AUTHORITATIVE_ANSWER = 1024, t.TRUNCATED_RESPONSE = 512, t.RECURSION_DESIRED = 256, t.RECURSION_AVAILABLE = 128, t.AUTHENTIC_DATA = 32, t.CHECKING_DISABLED = 16, t.DNSSEC_OK = 32768, t.encode = function (e, n, r) { n || (n = c.allocUnsafe(t.encodingLength(e))), r || (r = 0); const o = r; return e.questions || (e.questions = []), e.answers || (e.answers = []), e.authorities || (e.authorities = []), e.additionals || (e.additionals = []), h.encode(e, n, r), r += h.encode.bytes, r = T(e.questions, L, n, r), r = T(e.answers, O, n, r), r = T(e.authorities, O, n, r), r = T(e.additionals, O, n, r), t.encode.bytes = r - o, n }, t.encode.bytes = 0, t.decode = function (e, n) { n || (n = 0); const r = n, o = h.decode(e, n); return n += h.decode.bytes, n = C(o.questions, L, e, n), n = C(o.answers, O, e, n), n = C(o.authorities, O, e, n), n = C(o.additionals, O, e, n), t.decode.bytes = n - r, o }, t.decode.bytes = 0, t.encodingLength = function (e) { return h.encodingLength(e) + P(e.questions || [], L) + P(e.answers || [], O) + P(e.authorities || [], O) + P(e.additionals || [], O) }, t.streamEncode = function (e) { const n = t.encode(e), r = c.allocUnsafe(2); r.writeUInt16BE(n.byteLength); const o = c.concat([r, n]); return t.streamEncode.bytes = o.byteLength, o }, t.streamEncode.bytes = 0, t.streamDecode = function (e) { const n = e.readUInt16BE(0); if (e.byteLength < n + 2) return null; const r = t.decode(e.slice(2)); return t.streamDecode.bytes = t.decode.bytes, r }, t.streamDecode.bytes = 0 }, function (e, t, n) {
    "use strict"; (function (e) {
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <http://feross.org>
         * @license  MIT
         */
        var r = n(4), o = n(5), i = n(6); function s() { return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function u(e, t) { if (s() < t) throw new RangeError("Invalid typed array length"); return c.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = c.prototype : (null === e && (e = new c(t)), e.length = t), e } function c(e, t, n) { if (!(c.TYPED_ARRAY_SUPPORT || this instanceof c)) return new c(e, t, n); if ("number" == typeof e) { if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string"); return h(this, e) } return a(this, e, t, n) } function a(e, t, n, r) { if ("number" == typeof t) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function (e, t, n, r) { if (t.byteLength, n < 0 || t.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (t.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds"); t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r); c.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = c.prototype : e = d(e, t); return e }(e, t, n, r) : "string" == typeof t ? function (e, t, n) { "string" == typeof n && "" !== n || (n = "utf8"); if (!c.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | g(t, n), o = (e = u(e, r)).write(t, n); o !== r && (e = e.slice(0, o)); return e }(e, t, n) : function (e, t) { if (c.isBuffer(t)) { var n = 0 | l(t.length); return 0 === (e = u(e, n)).length ? e : (t.copy(e, 0, 0, n), e) } if (t) { if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || (r = t.length) != r ? u(e, 0) : d(e, t); if ("Buffer" === t.type && i(t.data)) return d(e, t.data) } var r; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") }(e, t) } function f(e) { if ("number" != typeof e) throw new TypeError('"size" argument must be a number'); if (e < 0) throw new RangeError('"size" argument must not be negative') } function h(e, t) { if (f(t), e = u(e, t < 0 ? 0 : 0 | l(t)), !c.TYPED_ARRAY_SUPPORT) for (var n = 0; n < t; ++n)e[n] = 0; return e } function d(e, t) { var n = t.length < 0 ? 0 : 0 | l(t.length); e = u(e, n); for (var r = 0; r < n; r += 1)e[r] = 255 & t[r]; return e } function l(e) { if (e >= s()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes"); return 0 | e } function g(e, t) { if (c.isBuffer(e)) return e.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength; "string" != typeof e && (e = "" + e); var n = e.length; if (0 === n) return 0; for (var r = !1; ;)switch (t) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return k(e).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return X(e).length; default: if (r) return k(e).length; t = ("" + t).toLowerCase(), r = !0 } } function p(e, t, n) { var r = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ""; if ((n >>>= 0) <= (t >>>= 0)) return ""; for (e || (e = "utf8"); ;)switch (e) { case "hex": return O(this, t, n); case "utf8": case "utf-8": return B(this, t, n); case "ascii": return S(this, t, n); case "latin1": case "binary": return _(this, t, n); case "base64": return R(this, t, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return L(this, t, n); default: if (r) throw new TypeError("Unknown encoding: " + e); e = (e + "").toLowerCase(), r = !0 } } function y(e, t, n) { var r = e[t]; e[t] = e[n], e[n] = r } function E(e, t, n, r, o) { if (0 === e.length) return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) { if (o) return -1; n = e.length - 1 } else if (n < 0) { if (!o) return -1; n = 0 } if ("string" == typeof t && (t = c.from(t, r)), c.isBuffer(t)) return 0 === t.length ? -1 : b(e, t, n, r, o); if ("number" == typeof t) return t &= 255, c.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : b(e, [t], n, r, o); throw new TypeError("val must be string, number or Buffer") } function b(e, t, n, r, o) { var i, s = 1, u = e.length, c = t.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (e.length < 2 || t.length < 2) return -1; s = 2, u /= 2, c /= 2, n /= 2 } function a(e, t) { return 1 === s ? e[t] : e.readUInt16BE(t * s) } if (o) { var f = -1; for (i = n; i < u; i++)if (a(e, i) === a(t, -1 === f ? 0 : i - f)) { if (-1 === f && (f = i), i - f + 1 === c) return f * s } else -1 !== f && (i -= i - f), f = -1 } else for (n + c > u && (n = u - c), i = n; i >= 0; i--) { for (var h = !0, d = 0; d < c; d++)if (a(e, i + d) !== a(t, d)) { h = !1; break } if (h) return i } return -1 } function w(e, t, n, r) { n = Number(n) || 0; var o = e.length - n; r ? (r = Number(r)) > o && (r = o) : r = o; var i = t.length; if (i % 2 != 0) throw new TypeError("Invalid hex string"); r > i / 2 && (r = i / 2); for (var s = 0; s < r; ++s) { var u = parseInt(t.substr(2 * s, 2), 16); if (isNaN(u)) return s; e[n + s] = u } return s } function A(e, t, n, r) { return j(k(t, e.length - n), e, n, r) } function U(e, t, n, r) { return j(function (e) { for (var t = [], n = 0; n < e.length; ++n)t.push(255 & e.charCodeAt(n)); return t }(t), e, n, r) } function m(e, t, n, r) { return U(e, t, n, r) } function v(e, t, n, r) { return j(X(t), e, n, r) } function I(e, t, n, r) { return j(function (e, t) { for (var n, r, o, i = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)n = e.charCodeAt(s), r = n >> 8, o = n % 256, i.push(o), i.push(r); return i }(t, e.length - n), e, n, r) } function R(e, t, n) { return 0 === t && n === e.length ? r.fromByteArray(e) : r.fromByteArray(e.slice(t, n)) } function B(e, t, n) { n = Math.min(e.length, n); for (var r = [], o = t; o < n;) { var i, s, u, c, a = e[o], f = null, h = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1; if (o + h <= n) switch (h) { case 1: a < 128 && (f = a); break; case 2: 128 == (192 & (i = e[o + 1])) && (c = (31 & a) << 6 | 63 & i) > 127 && (f = c); break; case 3: i = e[o + 1], s = e[o + 2], 128 == (192 & i) && 128 == (192 & s) && (c = (15 & a) << 12 | (63 & i) << 6 | 63 & s) > 2047 && (c < 55296 || c > 57343) && (f = c); break; case 4: i = e[o + 1], s = e[o + 2], u = e[o + 3], 128 == (192 & i) && 128 == (192 & s) && 128 == (192 & u) && (c = (15 & a) << 18 | (63 & i) << 12 | (63 & s) << 6 | 63 & u) > 65535 && c < 1114112 && (f = c) }null === f ? (f = 65533, h = 1) : f > 65535 && (f -= 65536, r.push(f >>> 10 & 1023 | 55296), f = 56320 | 1023 & f), r.push(f), o += h } return function (e) { var t = e.length; if (t <= 4096) return String.fromCharCode.apply(String, e); var n = "", r = 0; for (; r < t;)n += String.fromCharCode.apply(String, e.slice(r, r += 4096)); return n }(r) } t.Buffer = c, t.SlowBuffer = function (e) { +e != e && (e = 0); return c.alloc(+e) }, t.INSPECT_MAX_BYTES = 50, c.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : function () { try { var e = new Uint8Array(1); return e.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength } catch (e) { return !1 } }(), t.kMaxLength = s(), c.poolSize = 8192, c._augment = function (e) { return e.__proto__ = c.prototype, e }, c.from = function (e, t, n) { return a(null, e, t, n) }, c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype, c.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, { value: null, configurable: !0 })), c.alloc = function (e, t, n) { return function (e, t, n, r) { return f(t), t <= 0 ? u(e, t) : void 0 !== n ? "string" == typeof r ? u(e, t).fill(n, r) : u(e, t).fill(n) : u(e, t) }(null, e, t, n) }, c.allocUnsafe = function (e) { return h(null, e) }, c.allocUnsafeSlow = function (e) { return h(null, e) }, c.isBuffer = function (e) { return !(null == e || !e._isBuffer) }, c.compare = function (e, t) { if (!c.isBuffer(e) || !c.isBuffer(t)) throw new TypeError("Arguments must be Buffers"); if (e === t) return 0; for (var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o)if (e[o] !== t[o]) { n = e[o], r = t[o]; break } return n < r ? -1 : r < n ? 1 : 0 }, c.isEncoding = function (e) { switch (String(e).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, c.concat = function (e, t) { if (!i(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === e.length) return c.alloc(0); var n; if (void 0 === t) for (t = 0, n = 0; n < e.length; ++n)t += e[n].length; var r = c.allocUnsafe(t), o = 0; for (n = 0; n < e.length; ++n) { var s = e[n]; if (!c.isBuffer(s)) throw new TypeError('"list" argument must be an Array of Buffers'); s.copy(r, o), o += s.length } return r }, c.byteLength = g, c.prototype._isBuffer = !0, c.prototype.swap16 = function () { var e = this.length; if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var t = 0; t < e; t += 2)y(this, t, t + 1); return this }, c.prototype.swap32 = function () { var e = this.length; if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var t = 0; t < e; t += 4)y(this, t, t + 3), y(this, t + 1, t + 2); return this }, c.prototype.swap64 = function () { var e = this.length; if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var t = 0; t < e; t += 8)y(this, t, t + 7), y(this, t + 1, t + 6), y(this, t + 2, t + 5), y(this, t + 3, t + 4); return this }, c.prototype.toString = function () { var e = 0 | this.length; return 0 === e ? "" : 0 === arguments.length ? B(this, 0, e) : p.apply(this, arguments) }, c.prototype.equals = function (e) { if (!c.isBuffer(e)) throw new TypeError("Argument must be a Buffer"); return this === e || 0 === c.compare(this, e) }, c.prototype.inspect = function () { var e = "", n = t.INSPECT_MAX_BYTES; return this.length > 0 && (e = this.toString("hex", 0, n).match(/.{2}/g).join(" "), this.length > n && (e += " ... ")), "<Buffer " + e + ">" }, c.prototype.compare = function (e, t, n, r, o) { if (!c.isBuffer(e)) throw new TypeError("Argument must be a Buffer"); if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), t < 0 || n > e.length || r < 0 || o > this.length) throw new RangeError("out of range index"); if (r >= o && t >= n) return 0; if (r >= o) return -1; if (t >= n) return 1; if (this === e) return 0; for (var i = (o >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0), u = Math.min(i, s), a = this.slice(r, o), f = e.slice(t, n), h = 0; h < u; ++h)if (a[h] !== f[h]) { i = a[h], s = f[h]; break } return i < s ? -1 : s < i ? 1 : 0 }, c.prototype.includes = function (e, t, n) { return -1 !== this.indexOf(e, t, n) }, c.prototype.indexOf = function (e, t, n) { return E(this, e, t, n, !0) }, c.prototype.lastIndexOf = function (e, t, n) { return E(this, e, t, n, !1) }, c.prototype.write = function (e, t, n, r) { if (void 0 === t) r = "utf8", n = this.length, t = 0; else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0; else { if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); t |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0) } var o = this.length - t; if ((void 0 === n || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var i = !1; ;)switch (r) { case "hex": return w(this, e, t, n); case "utf8": case "utf-8": return A(this, e, t, n); case "ascii": return U(this, e, t, n); case "latin1": case "binary": return m(this, e, t, n); case "base64": return v(this, e, t, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return I(this, e, t, n); default: if (i) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), i = !0 } }, c.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function S(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var o = t; o < n; ++o)r += String.fromCharCode(127 & e[o]); return r } function _(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var o = t; o < n; ++o)r += String.fromCharCode(e[o]); return r } function O(e, t, n) { var r = e.length; (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r); for (var o = "", i = t; i < n; ++i)o += F(e[i]); return o } function L(e, t, n) { for (var r = e.slice(t, n), o = "", i = 0; i < r.length; i += 2)o += String.fromCharCode(r[i] + 256 * r[i + 1]); return o } function P(e, t, n) { if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint"); if (e + t > n) throw new RangeError("Trying to access beyond buffer length") } function T(e, t, n, r, o, i) { if (!c.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > o || t < i) throw new RangeError('"value" argument is out of bounds'); if (n + r > e.length) throw new RangeError("Index out of range") } function C(e, t, n, r) { t < 0 && (t = 65535 + t + 1); for (var o = 0, i = Math.min(e.length - n, 2); o < i; ++o)e[n + o] = (t & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o) } function D(e, t, n, r) { t < 0 && (t = 4294967295 + t + 1); for (var o = 0, i = Math.min(e.length - n, 4); o < i; ++o)e[n + o] = t >>> 8 * (r ? o : 3 - o) & 255 } function N(e, t, n, r, o, i) { if (n + r > e.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("Index out of range") } function Y(e, t, n, r, i) { return i || N(e, 0, n, 4), o.write(e, t, n, r, 23, 4), n + 4 } function M(e, t, n, r, i) { return i || N(e, 0, n, 8), o.write(e, t, n, r, 52, 8), n + 8 } c.prototype.slice = function (e, t) { var n, r = this.length; if ((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e), c.TYPED_ARRAY_SUPPORT) (n = this.subarray(e, t)).__proto__ = c.prototype; else { var o = t - e; n = new c(o, void 0); for (var i = 0; i < o; ++i)n[i] = this[i + e] } return n }, c.prototype.readUIntLE = function (e, t, n) { e |= 0, t |= 0, n || P(e, t, this.length); for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)r += this[e + i] * o; return r }, c.prototype.readUIntBE = function (e, t, n) { e |= 0, t |= 0, n || P(e, t, this.length); for (var r = this[e + --t], o = 1; t > 0 && (o *= 256);)r += this[e + --t] * o; return r }, c.prototype.readUInt8 = function (e, t) { return t || P(e, 1, this.length), this[e] }, c.prototype.readUInt16LE = function (e, t) { return t || P(e, 2, this.length), this[e] | this[e + 1] << 8 }, c.prototype.readUInt16BE = function (e, t) { return t || P(e, 2, this.length), this[e] << 8 | this[e + 1] }, c.prototype.readUInt32LE = function (e, t) { return t || P(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3] }, c.prototype.readUInt32BE = function (e, t) { return t || P(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]) }, c.prototype.readIntLE = function (e, t, n) { e |= 0, t |= 0, n || P(e, t, this.length); for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)r += this[e + i] * o; return r >= (o *= 128) && (r -= Math.pow(2, 8 * t)), r }, c.prototype.readIntBE = function (e, t, n) { e |= 0, t |= 0, n || P(e, t, this.length); for (var r = t, o = 1, i = this[e + --r]; r > 0 && (o *= 256);)i += this[e + --r] * o; return i >= (o *= 128) && (i -= Math.pow(2, 8 * t)), i }, c.prototype.readInt8 = function (e, t) { return t || P(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e] }, c.prototype.readInt16LE = function (e, t) { t || P(e, 2, this.length); var n = this[e] | this[e + 1] << 8; return 32768 & n ? 4294901760 | n : n }, c.prototype.readInt16BE = function (e, t) { t || P(e, 2, this.length); var n = this[e + 1] | this[e] << 8; return 32768 & n ? 4294901760 | n : n }, c.prototype.readInt32LE = function (e, t) { return t || P(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24 }, c.prototype.readInt32BE = function (e, t) { return t || P(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3] }, c.prototype.readFloatLE = function (e, t) { return t || P(e, 4, this.length), o.read(this, e, !0, 23, 4) }, c.prototype.readFloatBE = function (e, t) { return t || P(e, 4, this.length), o.read(this, e, !1, 23, 4) }, c.prototype.readDoubleLE = function (e, t) { return t || P(e, 8, this.length), o.read(this, e, !0, 52, 8) }, c.prototype.readDoubleBE = function (e, t) { return t || P(e, 8, this.length), o.read(this, e, !1, 52, 8) }, c.prototype.writeUIntLE = function (e, t, n, r) { (e = +e, t |= 0, n |= 0, r) || T(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); var o = 1, i = 0; for (this[t] = 255 & e; ++i < n && (o *= 256);)this[t + i] = e / o & 255; return t + n }, c.prototype.writeUIntBE = function (e, t, n, r) { (e = +e, t |= 0, n |= 0, r) || T(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); var o = n - 1, i = 1; for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);)this[t + o] = e / i & 255; return t + n }, c.prototype.writeUInt8 = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 1, 255, 0), c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1 }, c.prototype.writeUInt16LE = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : C(this, e, t, !0), t + 2 }, c.prototype.writeUInt16BE = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : C(this, e, t, !1), t + 2 }, c.prototype.writeUInt32LE = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : D(this, e, t, !0), t + 4 }, c.prototype.writeUInt32BE = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : D(this, e, t, !1), t + 4 }, c.prototype.writeIntLE = function (e, t, n, r) { if (e = +e, t |= 0, !r) { var o = Math.pow(2, 8 * n - 1); T(this, e, t, n, o - 1, -o) } var i = 0, s = 1, u = 0; for (this[t] = 255 & e; ++i < n && (s *= 256);)e < 0 && 0 === u && 0 !== this[t + i - 1] && (u = 1), this[t + i] = (e / s >> 0) - u & 255; return t + n }, c.prototype.writeIntBE = function (e, t, n, r) { if (e = +e, t |= 0, !r) { var o = Math.pow(2, 8 * n - 1); T(this, e, t, n, o - 1, -o) } var i = n - 1, s = 1, u = 0; for (this[t + i] = 255 & e; --i >= 0 && (s *= 256);)e < 0 && 0 === u && 0 !== this[t + i + 1] && (u = 1), this[t + i] = (e / s >> 0) - u & 255; return t + n }, c.prototype.writeInt8 = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 1, 127, -128), c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1 }, c.prototype.writeInt16LE = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : C(this, e, t, !0), t + 2 }, c.prototype.writeInt16BE = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : C(this, e, t, !1), t + 2 }, c.prototype.writeInt32LE = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 4, 2147483647, -2147483648), c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : D(this, e, t, !0), t + 4 }, c.prototype.writeInt32BE = function (e, t, n) { return e = +e, t |= 0, n || T(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : D(this, e, t, !1), t + 4 }, c.prototype.writeFloatLE = function (e, t, n) { return Y(this, e, t, !0, n) }, c.prototype.writeFloatBE = function (e, t, n) { return Y(this, e, t, !1, n) }, c.prototype.writeDoubleLE = function (e, t, n) { return M(this, e, t, !0, n) }, c.prototype.writeDoubleBE = function (e, t, n) { return M(this, e, t, !1, n) }, c.prototype.copy = function (e, t, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0; if (0 === e.length || 0 === this.length) return 0; if (t < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (r < 0) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n); var o, i = r - n; if (this === e && n < t && t < r) for (o = i - 1; o >= 0; --o)e[o + t] = this[o + n]; else if (i < 1e3 || !c.TYPED_ARRAY_SUPPORT) for (o = 0; o < i; ++o)e[o + t] = this[o + n]; else Uint8Array.prototype.set.call(e, this.subarray(n, n + i), t); return i }, c.prototype.fill = function (e, t, n, r) { if ("string" == typeof e) { if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) { var o = e.charCodeAt(0); o < 256 && (e = o) } if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !c.isEncoding(r)) throw new TypeError("Unknown encoding: " + r) } else "number" == typeof e && (e &= 255); if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index"); if (n <= t) return this; var i; if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e) for (i = t; i < n; ++i)this[i] = e; else { var s = c.isBuffer(e) ? e : k(new c(e, r).toString()), u = s.length; for (i = 0; i < n - t; ++i)this[i + t] = s[i % u] } return this }; var x = /[^+\/0-9A-Za-z-_]/g; function F(e) { return e < 16 ? "0" + e.toString(16) : e.toString(16) } function k(e, t) { var n; t = t || 1 / 0; for (var r = e.length, o = null, i = [], s = 0; s < r; ++s) { if ((n = e.charCodeAt(s)) > 55295 && n < 57344) { if (!o) { if (n > 56319) { (t -= 3) > -1 && i.push(239, 191, 189); continue } if (s + 1 === r) { (t -= 3) > -1 && i.push(239, 191, 189); continue } o = n; continue } if (n < 56320) { (t -= 3) > -1 && i.push(239, 191, 189), o = n; continue } n = 65536 + (o - 55296 << 10 | n - 56320) } else o && (t -= 3) > -1 && i.push(239, 191, 189); if (o = null, n < 128) { if ((t -= 1) < 0) break; i.push(n) } else if (n < 2048) { if ((t -= 2) < 0) break; i.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((t -= 3) < 0) break; i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error("Invalid code point"); if ((t -= 4) < 0) break; i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return i } function X(e) { return r.toByteArray(function (e) { if ((e = function (e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "") }(e).replace(x, "")).length < 2) return ""; for (; e.length % 4 != 0;)e += "="; return e }(e)) } function j(e, t, n, r) { for (var o = 0; o < r && !(o + n >= t.length || o >= e.length); ++o)t[o + n] = e[o]; return o }
    }).call(this, n(3))
}, function (e, t, n) { "use strict"; n.r(t), function (e) { n.d(t, "default", (function () { return o })); var r = n(0); function o(t, n, o, i, s) { const u = Object(r.encode)({ type: "query", id: (c = 1, a = 65534, Math.floor(Math.random() * (a - c + 1)) + c), flags: r.RECURSION_DESIRED, questions: [{ type: n, name: t }] }); var c, a; return new Promise((t, n) => { const c = new Request(s || o, { method: "POST", headers: Object.assign({ "Content-Type": "application/dns-message", "Content-Length": e.byteLength(u) }, s ? { "X-Proxy-URL": o } : {}), body: u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength) }); fetch(c).then(e => { if ("application/dns-message" !== e.headers.get("content-type")) throw e; return e.arrayBuffer() }).then(o => { try { const n = Object(r.decode)(e.from(new Uint8Array(o))); !0 === i && console.log("Response DNS: ", n), t(n) } catch (e) { !0 === i && console.error("Failed to parse message", e), n(e) } }).catch(e => n(e)) }) } }.call(this, n(1).Buffer) }, function (e, t) { var n; n = function () { return this }(); try { n = n || new Function("return this")() } catch (e) { "object" == typeof window && (n = window) } e.exports = n }, function (e, t, n) { "use strict"; t.byteLength = function (e) { var t = a(e), n = t[0], r = t[1]; return 3 * (n + r) / 4 - r }, t.toByteArray = function (e) { var t, n, r = a(e), s = r[0], u = r[1], c = new i(function (e, t, n) { return 3 * (t + n) / 4 - n }(0, s, u)), f = 0, h = u > 0 ? s - 4 : s; for (n = 0; n < h; n += 4)t = o[e.charCodeAt(n)] << 18 | o[e.charCodeAt(n + 1)] << 12 | o[e.charCodeAt(n + 2)] << 6 | o[e.charCodeAt(n + 3)], c[f++] = t >> 16 & 255, c[f++] = t >> 8 & 255, c[f++] = 255 & t; 2 === u && (t = o[e.charCodeAt(n)] << 2 | o[e.charCodeAt(n + 1)] >> 4, c[f++] = 255 & t); 1 === u && (t = o[e.charCodeAt(n)] << 10 | o[e.charCodeAt(n + 1)] << 4 | o[e.charCodeAt(n + 2)] >> 2, c[f++] = t >> 8 & 255, c[f++] = 255 & t); return c }, t.fromByteArray = function (e) { for (var t, n = e.length, o = n % 3, i = [], s = 0, u = n - o; s < u; s += 16383)i.push(f(e, s, s + 16383 > u ? u : s + 16383)); 1 === o ? (t = e[n - 1], i.push(r[t >> 2] + r[t << 4 & 63] + "==")) : 2 === o && (t = (e[n - 2] << 8) + e[n - 1], i.push(r[t >> 10] + r[t >> 4 & 63] + r[t << 2 & 63] + "=")); return i.join("") }; for (var r = [], o = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", u = 0, c = s.length; u < c; ++u)r[u] = s[u], o[s.charCodeAt(u)] = u; function a(e) { var t = e.length; if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var n = e.indexOf("="); return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4] } function f(e, t, n) { for (var o, i, s = [], u = t; u < n; u += 3)o = (e[u] << 16 & 16711680) + (e[u + 1] << 8 & 65280) + (255 & e[u + 2]), s.push(r[(i = o) >> 18 & 63] + r[i >> 12 & 63] + r[i >> 6 & 63] + r[63 & i]); return s.join("") } o["-".charCodeAt(0)] = 62, o["_".charCodeAt(0)] = 63 }, function (e, t) { t.read = function (e, t, n, r, o) { var i, s, u = 8 * o - r - 1, c = (1 << u) - 1, a = c >> 1, f = -7, h = n ? o - 1 : 0, d = n ? -1 : 1, l = e[t + h]; for (h += d, i = l & (1 << -f) - 1, l >>= -f, f += u; f > 0; i = 256 * i + e[t + h], h += d, f -= 8); for (s = i & (1 << -f) - 1, i >>= -f, f += r; f > 0; s = 256 * s + e[t + h], h += d, f -= 8); if (0 === i) i = 1 - a; else { if (i === c) return s ? NaN : 1 / 0 * (l ? -1 : 1); s += Math.pow(2, r), i -= a } return (l ? -1 : 1) * s * Math.pow(2, i - r) }, t.write = function (e, t, n, r, o, i) { var s, u, c, a = 8 * i - o - 1, f = (1 << a) - 1, h = f >> 1, d = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, l = r ? 0 : i - 1, g = r ? 1 : -1, p = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, s = f) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (t += s + h >= 1 ? d / c : d * Math.pow(2, 1 - h)) * c >= 2 && (s++, c /= 2), s + h >= f ? (u = 0, s = f) : s + h >= 1 ? (u = (t * c - 1) * Math.pow(2, o), s += h) : (u = t * Math.pow(2, h - 1) * Math.pow(2, o), s = 0)); o >= 8; e[n + l] = 255 & u, l += g, u /= 256, o -= 8); for (s = s << o | u, a += o; a > 0; e[n + l] = 255 & s, l += g, s /= 256, a -= 8); e[n + l - g] |= 128 * p } }, function (e, t) { var n = {}.toString; e.exports = Array.isArray || function (e) { return "[object Array]" == n.call(e) } }, function (e, t, n) { "use strict"; t.toString = function (e) { switch (e) { case 1: return "A"; case 10: return "NULL"; case 28: return "AAAA"; case 18: return "AFSDB"; case 42: return "APL"; case 257: return "CAA"; case 60: return "CDNSKEY"; case 59: return "CDS"; case 37: return "CERT"; case 5: return "CNAME"; case 49: return "DHCID"; case 32769: return "DLV"; case 39: return "DNAME"; case 48: return "DNSKEY"; case 43: return "DS"; case 55: return "HIP"; case 13: return "HINFO"; case 45: return "IPSECKEY"; case 25: return "KEY"; case 36: return "KX"; case 29: return "LOC"; case 15: return "MX"; case 35: return "NAPTR"; case 2: return "NS"; case 47: return "NSEC"; case 50: return "NSEC3"; case 51: return "NSEC3PARAM"; case 12: return "PTR"; case 46: return "RRSIG"; case 17: return "RP"; case 24: return "SIG"; case 6: return "SOA"; case 99: return "SPF"; case 33: return "SRV"; case 44: return "SSHFP"; case 32768: return "TA"; case 249: return "TKEY"; case 52: return "TLSA"; case 250: return "TSIG"; case 16: return "TXT"; case 252: return "AXFR"; case 251: return "IXFR"; case 41: return "OPT"; case 255: return "ANY" }return "UNKNOWN_" + e }, t.toType = function (e) { switch (e.toUpperCase()) { case "A": return 1; case "NULL": return 10; case "AAAA": return 28; case "AFSDB": return 18; case "APL": return 42; case "CAA": return 257; case "CDNSKEY": return 60; case "CDS": return 59; case "CERT": return 37; case "CNAME": return 5; case "DHCID": return 49; case "DLV": return 32769; case "DNAME": return 39; case "DNSKEY": return 48; case "DS": return 43; case "HIP": return 55; case "HINFO": return 13; case "IPSECKEY": return 45; case "KEY": return 25; case "KX": return 36; case "LOC": return 29; case "MX": return 15; case "NAPTR": return 35; case "NS": return 2; case "NSEC": return 47; case "NSEC3": return 50; case "NSEC3PARAM": return 51; case "PTR": return 12; case "RRSIG": return 46; case "RP": return 17; case "SIG": return 24; case "SOA": return 6; case "SPF": return 99; case "SRV": return 33; case "SSHFP": return 44; case "TA": return 32768; case "TKEY": return 249; case "TLSA": return 52; case "TSIG": return 250; case "TXT": return 16; case "AXFR": return 252; case "IXFR": return 251; case "OPT": return 41; case "ANY": case "*": return 255 }return 0 } }, function (e, t, n) { "use strict"; t.toString = function (e) { switch (e) { case 0: return "NOERROR"; case 1: return "FORMERR"; case 2: return "SERVFAIL"; case 3: return "NXDOMAIN"; case 4: return "NOTIMP"; case 5: return "REFUSED"; case 6: return "YXDOMAIN"; case 7: return "YXRRSET"; case 8: return "NXRRSET"; case 9: return "NOTAUTH"; case 10: return "NOTZONE"; case 11: return "RCODE_11"; case 12: return "RCODE_12"; case 13: return "RCODE_13"; case 14: return "RCODE_14"; case 15: return "RCODE_15" }return "RCODE_" + e }, t.toRcode = function (e) { switch (e.toUpperCase()) { case "NOERROR": return 0; case "FORMERR": return 1; case "SERVFAIL": return 2; case "NXDOMAIN": return 3; case "NOTIMP": return 4; case "REFUSED": return 5; case "YXDOMAIN": return 6; case "YXRRSET": return 7; case "NXRRSET": return 8; case "NOTAUTH": return 9; case "NOTZONE": return 10; case "RCODE_11": return 11; case "RCODE_12": return 12; case "RCODE_13": return 13; case "RCODE_14": return 14; case "RCODE_15": return 15 }return 0 } }, function (e, t, n) { "use strict"; t.toString = function (e) { switch (e) { case 0: return "QUERY"; case 1: return "IQUERY"; case 2: return "STATUS"; case 3: return "OPCODE_3"; case 4: return "NOTIFY"; case 5: return "UPDATE"; case 6: return "OPCODE_6"; case 7: return "OPCODE_7"; case 8: return "OPCODE_8"; case 9: return "OPCODE_9"; case 10: return "OPCODE_10"; case 11: return "OPCODE_11"; case 12: return "OPCODE_12"; case 13: return "OPCODE_13"; case 14: return "OPCODE_14"; case 15: return "OPCODE_15" }return "OPCODE_" + e }, t.toOpcode = function (e) { switch (e.toUpperCase()) { case "QUERY": return 0; case "IQUERY": return 1; case "STATUS": return 2; case "OPCODE_3": return 3; case "NOTIFY": return 4; case "UPDATE": return 5; case "OPCODE_6": return 6; case "OPCODE_7": return 7; case "OPCODE_8": return 8; case "OPCODE_9": return 9; case "OPCODE_10": return 10; case "OPCODE_11": return 11; case "OPCODE_12": return 12; case "OPCODE_13": return 13; case "OPCODE_14": return 14; case "OPCODE_15": return 15 }return 0 } }, function (e, t, n) { "use strict"; t.toString = function (e) { switch (e) { case 1: return "IN"; case 2: return "CS"; case 3: return "CH"; case 4: return "HS"; case 255: return "ANY" }return "UNKNOWN_" + e }, t.toClass = function (e) { switch (e.toUpperCase()) { case "IN": return 1; case "CS": return 2; case "CH": return 3; case "HS": return 4; case "ANY": return 255 }return 0 } }, function (e, t, n) { "use strict"; var r = t, o = n(1).Buffer, i = n(12); r.toBuffer = function (e, t, n) { var r; if (n = ~~n, this.isV4Format(e)) r = t || new o(n + 4), e.split(/\./g).map((function (e) { r[n++] = 255 & parseInt(e, 10) })); else if (this.isV6Format(e)) { var i, s = e.split(":", 8); for (i = 0; i < s.length; i++) { var u; this.isV4Format(s[i]) && (u = this.toBuffer(s[i]), s[i] = u.slice(0, 2).toString("hex")), u && ++i < 8 && s.splice(i, 0, u.slice(2, 4).toString("hex")) } if ("" === s[0]) for (; s.length < 8;)s.unshift("0"); else if ("" === s[s.length - 1]) for (; s.length < 8;)s.push("0"); else if (s.length < 8) { for (i = 0; i < s.length && "" !== s[i]; i++); var c = [i, 1]; for (i = 9 - s.length; i > 0; i--)c.push("0"); s.splice.apply(s, c) } for (r = t || new o(n + 16), i = 0; i < s.length; i++) { var a = parseInt(s[i], 16); r[n++] = a >> 8 & 255, r[n++] = 255 & a } } if (!r) throw Error("Invalid ip address: " + e); return r }, r.toString = function (e, t, n) { t = ~~t; var r = []; if (4 === (n = n || e.length - t)) { for (var o = 0; o < n; o++)r.push(e[t + o]); r = r.join(".") } else if (16 === n) { for (o = 0; o < n; o += 2)r.push(e.readUInt16BE(t + o).toString(16)); r = (r = (r = r.join(":")).replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3")).replace(/:{3,4}/, "::") } return r }; var s = /^(\d{1,3}\.){3,3}\d{1,3}$/, u = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i; function c(e) { return e ? e.toLowerCase() : "ipv4" } r.isV4Format = function (e) { return s.test(e) }, r.isV6Format = function (e) { return u.test(e) }, r.fromPrefixLen = function (e, t) { var n = 4; "ipv6" === (t = e > 32 ? "ipv6" : c(t)) && (n = 16); for (var i = new o(n), s = 0, u = i.length; s < u; ++s) { var a = 8; e < 8 && (a = e), e -= a, i[s] = 255 & ~(255 >> a) } return r.toString(i) }, r.mask = function (e, t) { e = r.toBuffer(e), t = r.toBuffer(t); var n = new o(Math.max(e.length, t.length)), i = 0; if (e.length === t.length) for (i = 0; i < e.length; i++)n[i] = e[i] & t[i]; else if (4 === t.length) for (i = 0; i < t.length; i++)n[i] = e[e.length - 4 + i] & t[i]; else { for (i = 0; i < n.length - 6; i++)n[i] = 0; for (n[10] = 255, n[11] = 255, i = 0; i < e.length; i++)n[i + 12] = e[i] & t[i + 12]; i += 12 } for (; i < n.length; i++)n[i] = 0; return r.toString(n) }, r.cidr = function (e) { var t = e.split("/"), n = t[0]; if (2 !== t.length) throw new Error("invalid CIDR subnet: " + n); var o = r.fromPrefixLen(parseInt(t[1], 10)); return r.mask(n, o) }, r.subnet = function (e, t) { for (var n = r.toLong(r.mask(e, t)), o = r.toBuffer(t), i = 0, s = 0; s < o.length; s++)if (255 === o[s]) i += 8; else for (var u = 255 & o[s]; u;)u = u << 1 & 255, i++; var c = Math.pow(2, 32 - i); return { networkAddress: r.fromLong(n), firstAddress: c <= 2 ? r.fromLong(n) : r.fromLong(n + 1), lastAddress: c <= 2 ? r.fromLong(n + c - 1) : r.fromLong(n + c - 2), broadcastAddress: r.fromLong(n + c - 1), subnetMask: t, subnetMaskLength: i, numHosts: c <= 2 ? c : c - 2, length: c, contains: function (e) { return n === r.toLong(r.mask(e, t)) } } }, r.cidrSubnet = function (e) { var t = e.split("/"), n = t[0]; if (2 !== t.length) throw new Error("invalid CIDR subnet: " + n); var o = r.fromPrefixLen(parseInt(t[1], 10)); return r.subnet(n, o) }, r.not = function (e) { for (var t = r.toBuffer(e), n = 0; n < t.length; n++)t[n] = 255 ^ t[n]; return r.toString(t) }, r.or = function (e, t) { if (e = r.toBuffer(e), t = r.toBuffer(t), e.length === t.length) { for (var n = 0; n < e.length; ++n)e[n] |= t[n]; return r.toString(e) } var o = e, i = t; t.length > e.length && (o = t, i = e); var s = o.length - i.length; for (n = s; n < o.length; ++n)o[n] |= i[n - s]; return r.toString(o) }, r.isEqual = function (e, t) { if (e = r.toBuffer(e), t = r.toBuffer(t), e.length === t.length) { for (var n = 0; n < e.length; n++)if (e[n] !== t[n]) return !1; return !0 } if (4 === t.length) { var o = t; t = e, e = o } for (n = 0; n < 10; n++)if (0 !== t[n]) return !1; var i = t.readUInt16BE(10); if (0 !== i && 65535 !== i) return !1; for (n = 0; n < 4; n++)if (e[n] !== t[n + 12]) return !1; return !0 }, r.isPrivate = function (e) { return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(e) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(e) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(e) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(e) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(e) || /^f[cd][0-9a-f]{2}:/i.test(e) || /^fe80:/i.test(e) || /^::1$/.test(e) || /^::$/.test(e) }, r.isPublic = function (e) { return !r.isPrivate(e) }, r.isLoopback = function (e) { return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(e) || /^fe80::1$/.test(e) || /^::1$/.test(e) || /^::$/.test(e) }, r.loopback = function (e) { if ("ipv4" !== (e = c(e)) && "ipv6" !== e) throw new Error("family must be ipv4 or ipv6"); return "ipv4" === e ? "0.0.0.0" : "fe80::1" }, r.address = function (e, t) { var n, o = i.networkInterfaces(); if (t = c(t), e && "private" !== e && "public" !== e) { var s = o[e].filter((function (e) { return e.family.toLowerCase() === t })); if (0 === s.length) return; return s[0].address } return (n = Object.keys(o).map((function (n) { var i = o[n].filter((function (n) { return n.family = n.family.toLowerCase(), n.family === t && !r.isLoopback(n.address) && (!e || ("public" === e ? r.isPrivate(n.address) : r.isPublic(n.address))) })); return i.length ? i[0].address : void 0 })).filter(Boolean)).length ? n[0] : r.loopback(t) }, r.toLong = function (e) { var t = 0; return e.split(".").forEach((function (e) { t <<= 8, t += parseInt(e) })), t >>> 0 }, r.fromLong = function (e) { return (e >>> 24) + "." + (e >> 16 & 255) + "." + (e >> 8 & 255) + "." + (255 & e) } }, function (e, t) { t.endianness = function () { return "LE" }, t.hostname = function () { return "undefined" != typeof location ? location.hostname : "" }, t.loadavg = function () { return [] }, t.uptime = function () { return 0 }, t.freemem = function () { return Number.MAX_VALUE }, t.totalmem = function () { return Number.MAX_VALUE }, t.cpus = function () { return [] }, t.type = function () { return "Browser" }, t.release = function () { return "undefined" != typeof navigator ? navigator.appVersion : "" }, t.networkInterfaces = t.getNetworkInterfaces = function () { return {} }, t.arch = function () { return "javascript" }, t.platform = function () { return "browser" }, t.tmpdir = t.tmpDir = function () { return "/tmp" }, t.EOL = "\n", t.homedir = function () { return "/" } }, function (e, t, n) { var r = n(1), o = r.Buffer; function i(e, t) { for (var n in e) t[n] = e[n] } function s(e, t, n) { return o(e, t, n) } o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = s), i(o, s), s.from = function (e, t, n) { if ("number" == typeof e) throw new TypeError("Argument must not be a number"); return o(e, t, n) }, s.alloc = function (e, t, n) { if ("number" != typeof e) throw new TypeError("Argument must be a number"); var r = o(e); return void 0 !== t ? "string" == typeof n ? r.fill(t, n) : r.fill(t) : r.fill(0), r }, s.allocUnsafe = function (e) { if ("number" != typeof e) throw new TypeError("Argument must be a number"); return o(e) }, s.allocUnsafeSlow = function (e) { if ("number" != typeof e) throw new TypeError("Argument must be a number"); return r.SlowBuffer(e) } }]).default;